/* tslint:disable */
/* eslint-disable */
/**
 * JulyLand - management [dev]
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BrandCreate
 */
export interface BrandCreate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrandCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BrandCreate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BrandCreate
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BrandCreate
     */
    'category_id': string;
}
/**
 * 
 * @export
 * @interface BrandPublic
 */
export interface BrandPublic {
    /**
     * 
     * @type {string}
     * @memberof BrandPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof BrandPublic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BrandPublic
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BrandPublic
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {CategoryPublic}
     * @memberof BrandPublic
     */
    'category': CategoryPublic;
}
/**
 * 
 * @export
 * @interface BrandUpdate
 */
export interface BrandUpdate {
    /**
     * 
     * @type {string}
     * @memberof BrandUpdate
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof BrandUpdate
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof BrandUpdate
     */
    'logo_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof BrandUpdate
     */
    'category_id': string | null;
}
/**
 * 
 * @export
 * @interface CategoryCreate
 */
export interface CategoryCreate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof CategoryCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryCreate
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CategoryCreate
     */
    'subcategories'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CategoryPublic
 */
export interface CategoryPublic {
    /**
     * 
     * @type {string}
     * @memberof CategoryPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryPublic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryPublic
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CategoryPublic
     */
    'subcategories'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CategoryUpdate
 */
export interface CategoryUpdate {
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdate
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdate
     */
    'description': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CategoryUpdate
     */
    'subcategories': Array<string> | null;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface InventoryCreate
 */
export interface InventoryCreate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof InventoryCreate
     */
    'variant_id': string;
    /**
     * 
     * @type {string}
     * @memberof InventoryCreate
     */
    'change_type': InventoryCreateChangeTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof InventoryCreate
     */
    'quantity': number;
}

export const InventoryCreateChangeTypeEnum = {
    In: 'in',
    Out: 'out',
    Adjust: 'adjust'
} as const;

export type InventoryCreateChangeTypeEnum = typeof InventoryCreateChangeTypeEnum[keyof typeof InventoryCreateChangeTypeEnum];

/**
 * 
 * @export
 * @interface InventoryPublic
 */
export interface InventoryPublic {
    /**
     * 
     * @type {string}
     * @memberof InventoryPublic
     */
    '_id': string;
    /**
     * 
     * @type {VariantPublic}
     * @memberof InventoryPublic
     */
    'variant': VariantPublic;
    /**
     * 
     * @type {string}
     * @memberof InventoryPublic
     */
    'change_type': InventoryPublicChangeTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof InventoryPublic
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof InventoryPublic
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof InventoryPublic
     */
    'updated_at': string;
}

export const InventoryPublicChangeTypeEnum = {
    In: 'in',
    Out: 'out',
    Adjust: 'adjust'
} as const;

export type InventoryPublicChangeTypeEnum = typeof InventoryPublicChangeTypeEnum[keyof typeof InventoryPublicChangeTypeEnum];

/**
 * 
 * @export
 * @interface ItemPublic
 */
export interface ItemPublic {
    /**
     * 
     * @type {string}
     * @memberof ItemPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemPublic
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemPublic
     */
    'item_name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemPublic
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof ItemPublic
     */
    'brand_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemPublic
     */
    'brand_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemPublic
     */
    'thumbnail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemPublic
     */
    'ship_info'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ItemPublic
     */
    'is_official': boolean;
}
/**
 * 
 * @export
 * @interface ItemSnapshotPublic
 */
export interface ItemSnapshotPublic {
    /**
     * 
     * @type {string}
     * @memberof ItemSnapshotPublic
     */
    '_id': string;
    /**
     * 
     * @type {ItemPublic}
     * @memberof ItemSnapshotPublic
     */
    'item': ItemPublic;
    /**
     * 
     * @type {string}
     * @memberof ItemSnapshotPublic
     */
    'category'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ItemSnapshotPublic
     */
    'rank': number | null;
    /**
     * 
     * @type {number}
     * @memberof ItemSnapshotPublic
     */
    'sold': number | null;
    /**
     * 
     * @type {number}
     * @memberof ItemSnapshotPublic
     */
    'original_price': number | null;
    /**
     * 
     * @type {number}
     * @memberof ItemSnapshotPublic
     */
    'sale_price': number | null;
    /**
     * 
     * @type {number}
     * @memberof ItemSnapshotPublic
     */
    'discount_rate': number | null;
    /**
     * 
     * @type {number}
     * @memberof ItemSnapshotPublic
     */
    'mega_price': number | null;
    /**
     * 
     * @type {number}
     * @memberof ItemSnapshotPublic
     */
    'mega_discount_rate': number | null;
    /**
     * 
     * @type {number}
     * @memberof ItemSnapshotPublic
     */
    'review_count': number | null;
}
/**
 * 
 * @export
 * @interface ListingCreate
 */
export interface ListingCreate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'market_place_id': string;
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'variant_id': string;
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'marketplace_item_id': string;
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'status': ListingCreateStatusEnum;
}

export const ListingCreateStatusEnum = {
    Draft: 'draft',
    Published: 'published',
    Error: 'error'
} as const;

export type ListingCreateStatusEnum = typeof ListingCreateStatusEnum[keyof typeof ListingCreateStatusEnum];

/**
 * 
 * @export
 * @interface ListingPublic
 */
export interface ListingPublic {
    /**
     * 
     * @type {string}
     * @memberof ListingPublic
     */
    '_id': string;
    /**
     * 
     * @type {VariantPublic}
     * @memberof ListingPublic
     */
    'variant': VariantPublic;
    /**
     * 
     * @type {MarketPlacePublic}
     * @memberof ListingPublic
     */
    'marketplace': MarketPlacePublic;
    /**
     * 
     * @type {string}
     * @memberof ListingPublic
     */
    'marketplace_item_id': string;
    /**
     * 
     * @type {string}
     * @memberof ListingPublic
     */
    'status': ListingPublicStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ListingPublic
     */
    'last_synced': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingPublic
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ListingPublic
     */
    'updated_at': string;
}

export const ListingPublicStatusEnum = {
    Draft: 'draft',
    Published: 'published',
    Error: 'error'
} as const;

export type ListingPublicStatusEnum = typeof ListingPublicStatusEnum[keyof typeof ListingPublicStatusEnum];

/**
 * 
 * @export
 * @interface LocaleName
 */
export interface LocaleName {
    /**
     * 
     * @type {string}
     * @memberof LocaleName
     */
    'locale': string;
    /**
     * 
     * @type {string}
     * @memberof LocaleName
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface MarketPlaceCreate
 */
export interface MarketPlaceCreate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof MarketPlaceCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MarketPlaceCreate
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface MarketPlacePublic
 */
export interface MarketPlacePublic {
    /**
     * 
     * @type {string}
     * @memberof MarketPlacePublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof MarketPlacePublic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MarketPlacePublic
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface MarketPlaceUpdate
 */
export interface MarketPlaceUpdate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof MarketPlaceUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MarketPlaceUpdate
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface MediaAssetCreate
 */
export interface MediaAssetCreate {
    /**
     * 
     * @type {string}
     * @memberof MediaAssetCreate
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof MediaAssetCreate
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof MediaAssetCreate
     */
    'mime_type': string;
}
/**
 * 
 * @export
 * @interface MediaAssetPublic
 */
export interface MediaAssetPublic {
    /**
     * 
     * @type {string}
     * @memberof MediaAssetPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof MediaAssetPublic
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof MediaAssetPublic
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof MediaAssetPublic
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof MediaAssetPublic
     */
    'mime_type': string;
    /**
     * 
     * @type {string}
     * @memberof MediaAssetPublic
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof MediaAssetPublic
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ProductCreate
 */
export interface ProductCreate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProductCreate
     */
    'name': string;
    /**
     * 
     * @type {Array<LocaleName>}
     * @memberof ProductCreate
     */
    'locale_names': Array<LocaleName>;
    /**
     * 
     * @type {string}
     * @memberof ProductCreate
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductCreate
     */
    'media_urls'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProductCreate
     */
    'brand_id': string;
}
/**
 * 
 * @export
 * @interface ProductPublic
 */
export interface ProductPublic {
    /**
     * 
     * @type {string}
     * @memberof ProductPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductPublic
     */
    'name': string;
    /**
     * 
     * @type {Array<LocaleName>}
     * @memberof ProductPublic
     */
    'locale_names': Array<LocaleName>;
    /**
     * 
     * @type {string}
     * @memberof ProductPublic
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductPublic
     */
    'media_urls'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProductPublic
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProductPublic
     */
    'updated_at': string;
    /**
     * 
     * @type {BrandPublic}
     * @memberof ProductPublic
     */
    'brand': BrandPublic;
}
/**
 * 
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<LocaleName>}
     * @memberof ProductUpdate
     */
    'locale_names'?: Array<LocaleName> | null;
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'description': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductUpdate
     */
    'media_urls'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'brand_id': string | null;
}
/**
 * 
 * @export
 * @interface RankingPublic
 */
export interface RankingPublic {
    /**
     * 
     * @type {string}
     * @memberof RankingPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof RankingPublic
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof RankingPublic
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof RankingPublic
     */
    'counts': number;
}
/**
 * 
 * @export
 * @interface RankingSnapshotPublic
 */
export interface RankingSnapshotPublic {
    /**
     * 
     * @type {string}
     * @memberof RankingSnapshotPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof RankingSnapshotPublic
     */
    'category': string;
    /**
     * 
     * @type {Array<ItemSnapshotPublic>}
     * @memberof RankingSnapshotPublic
     */
    'items': Array<ItemSnapshotPublic>;
    /**
     * 
     * @type {string}
     * @memberof RankingSnapshotPublic
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
}
/**
 * 
 * @export
 * @interface VariantCreate
 */
export interface VariantCreate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof VariantCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VariantCreate
     */
    'barcode'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantCreate
     */
    'media_urls'?: Array<string> | null;
    /**
     * 
     * @type {Array<VariantOption>}
     * @memberof VariantCreate
     */
    'options'?: Array<VariantOption> | null;
    /**
     * 
     * @type {number}
     * @memberof VariantCreate
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof VariantCreate
     */
    'product_id': string;
}
/**
 * 
 * @export
 * @interface VariantOption
 */
export interface VariantOption {
    /**
     * 
     * @type {string}
     * @memberof VariantOption
     */
    'name': string;
    /**
     * 
     * @type {Value}
     * @memberof VariantOption
     */
    'value': Value;
    /**
     * 
     * @type {string}
     * @memberof VariantOption
     */
    'unit'?: string | null;
}
/**
 * 
 * @export
 * @interface VariantPublic
 */
export interface VariantPublic {
    /**
     * 
     * @type {string}
     * @memberof VariantPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof VariantPublic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VariantPublic
     */
    'barcode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VariantPublic
     */
    'sku': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantPublic
     */
    'media_urls': Array<string> | null;
    /**
     * 
     * @type {Array<VariantOption>}
     * @memberof VariantPublic
     */
    'options': Array<VariantOption> | null;
    /**
     * 
     * @type {number}
     * @memberof VariantPublic
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof VariantPublic
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VariantPublic
     */
    'updated_at': string;
    /**
     * 
     * @type {ProductPublic}
     * @memberof VariantPublic
     */
    'product': ProductPublic;
}
/**
 * 
 * @export
 * @interface VariantUpdate
 */
export interface VariantUpdate {
    /**
     * 
     * @type {string}
     * @memberof VariantUpdate
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof VariantUpdate
     */
    'barcode'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantUpdate
     */
    'media_urls'?: Array<string> | null;
    /**
     * 
     * @type {Array<VariantOption>}
     * @memberof VariantUpdate
     */
    'options': Array<VariantOption> | null;
    /**
     * 
     * @type {number}
     * @memberof VariantUpdate
     */
    'price': number | null;
    /**
     * 
     * @type {string}
     * @memberof VariantUpdate
     */
    'product_id': string | null;
}

/**
 * BrandApi - axios parameter creator
 * @export
 */
export const BrandApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Brand
         * @param {BrandCreate} brandCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandCreateBrand: async (brandCreate: BrandCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandCreate' is not null or undefined
            assertParamExists('brandCreateBrand', 'brandCreate', brandCreate)
            const localVarPath = `/api/v1/brands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(brandCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Brand
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandDeleteBrand: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('brandDeleteBrand', 'id', id)
            const localVarPath = `/api/v1/brands/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Brands
         * @param {string | null} [categoryName] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandListBrands: async (categoryName?: string | null, skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/brands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (categoryName !== undefined) {
                localVarQueryParameter['category_name'] = categoryName;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Brand
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandReadBrand: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('brandReadBrand', 'id', id)
            const localVarPath = `/api/v1/brands/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Brand
         * @param {string} id 
         * @param {BrandUpdate} brandUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandUpdateBrand: async (id: string, brandUpdate: BrandUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('brandUpdateBrand', 'id', id)
            // verify required parameter 'brandUpdate' is not null or undefined
            assertParamExists('brandUpdateBrand', 'brandUpdate', brandUpdate)
            const localVarPath = `/api/v1/brands/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(brandUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandApi - functional programming interface
 * @export
 */
export const BrandApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Brand
         * @param {BrandCreate} brandCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandCreateBrand(brandCreate: BrandCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandCreateBrand(brandCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandApi.brandCreateBrand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Brand
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandDeleteBrand(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandDeleteBrand(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandApi.brandDeleteBrand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Brands
         * @param {string | null} [categoryName] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandListBrands(categoryName?: string | null, skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BrandPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandListBrands(categoryName, skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandApi.brandListBrands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Brand
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandReadBrand(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandReadBrand(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandApi.brandReadBrand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Brand
         * @param {string} id 
         * @param {BrandUpdate} brandUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandUpdateBrand(id: string, brandUpdate: BrandUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandUpdateBrand(id, brandUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandApi.brandUpdateBrand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrandApi - factory interface
 * @export
 */
export const BrandApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Brand
         * @param {BrandCreate} brandCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandCreateBrand(brandCreate: BrandCreate, options?: RawAxiosRequestConfig): AxiosPromise<BrandPublic> {
            return localVarFp.brandCreateBrand(brandCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Brand
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandDeleteBrand(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.brandDeleteBrand(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Brands
         * @param {string | null} [categoryName] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandListBrands(categoryName?: string | null, skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<BrandPublic>> {
            return localVarFp.brandListBrands(categoryName, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Brand
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandReadBrand(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BrandPublic> {
            return localVarFp.brandReadBrand(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Brand
         * @param {string} id 
         * @param {BrandUpdate} brandUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandUpdateBrand(id: string, brandUpdate: BrandUpdate, options?: RawAxiosRequestConfig): AxiosPromise<BrandPublic> {
            return localVarFp.brandUpdateBrand(id, brandUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandApi - object-oriented interface
 * @export
 * @class BrandApi
 * @extends {BaseAPI}
 */
export class BrandApi extends BaseAPI {
    /**
     * 
     * @summary Create Brand
     * @param {BrandCreate} brandCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandApi
     */
    public brandCreateBrand(brandCreate: BrandCreate, options?: RawAxiosRequestConfig) {
        return BrandApiFp(this.configuration).brandCreateBrand(brandCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Brand
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandApi
     */
    public brandDeleteBrand(id: string, options?: RawAxiosRequestConfig) {
        return BrandApiFp(this.configuration).brandDeleteBrand(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Brands
     * @param {string | null} [categoryName] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandApi
     */
    public brandListBrands(categoryName?: string | null, skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return BrandApiFp(this.configuration).brandListBrands(categoryName, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Brand
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandApi
     */
    public brandReadBrand(id: string, options?: RawAxiosRequestConfig) {
        return BrandApiFp(this.configuration).brandReadBrand(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Brand
     * @param {string} id 
     * @param {BrandUpdate} brandUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandApi
     */
    public brandUpdateBrand(id: string, brandUpdate: BrandUpdate, options?: RawAxiosRequestConfig) {
        return BrandApiFp(this.configuration).brandUpdateBrand(id, brandUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Category
         * @param {CategoryCreate} categoryCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryCreateCategory: async (categoryCreate: CategoryCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryCreate' is not null or undefined
            assertParamExists('categoryCreateCategory', 'categoryCreate', categoryCreate)
            const localVarPath = `/api/v1/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryDeleteCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryDeleteCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Categories
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryListCategories: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Category
         * @param {string} categoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryReadCategory: async (categoryName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('categoryReadCategory', 'categoryName', categoryName)
            const localVarPath = `/api/v1/categories/{category_name}`
                .replace(`{${"category_name"}}`, encodeURIComponent(String(categoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Category
         * @param {string} id 
         * @param {CategoryUpdate} categoryUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryUpdateCategory: async (id: string, categoryUpdate: CategoryUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryUpdateCategory', 'id', id)
            // verify required parameter 'categoryUpdate' is not null or undefined
            assertParamExists('categoryUpdateCategory', 'categoryUpdate', categoryUpdate)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Category
         * @param {CategoryCreate} categoryCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryCreateCategory(categoryCreate: CategoryCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryCreateCategory(categoryCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryCreateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryDeleteCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryDeleteCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryDeleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Categories
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryListCategories(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryListCategories(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryListCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Category
         * @param {string} categoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryReadCategory(categoryName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryReadCategory(categoryName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryReadCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Category
         * @param {string} id 
         * @param {CategoryUpdate} categoryUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryUpdateCategory(id: string, categoryUpdate: CategoryUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryUpdateCategory(id, categoryUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryUpdateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Category
         * @param {CategoryCreate} categoryCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryCreateCategory(categoryCreate: CategoryCreate, options?: RawAxiosRequestConfig): AxiosPromise<CategoryPublic> {
            return localVarFp.categoryCreateCategory(categoryCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryDeleteCategory(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.categoryDeleteCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Categories
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryListCategories(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<CategoryPublic>> {
            return localVarFp.categoryListCategories(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Category
         * @param {string} categoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryReadCategory(categoryName: string, options?: RawAxiosRequestConfig): AxiosPromise<CategoryPublic> {
            return localVarFp.categoryReadCategory(categoryName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Category
         * @param {string} id 
         * @param {CategoryUpdate} categoryUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryUpdateCategory(id: string, categoryUpdate: CategoryUpdate, options?: RawAxiosRequestConfig): AxiosPromise<CategoryPublic> {
            return localVarFp.categoryUpdateCategory(id, categoryUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @summary Create Category
     * @param {CategoryCreate} categoryCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryCreateCategory(categoryCreate: CategoryCreate, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryCreateCategory(categoryCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Category
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryDeleteCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryDeleteCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Categories
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryListCategories(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryListCategories(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Category
     * @param {string} categoryName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryReadCategory(categoryName: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryReadCategory(categoryName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Category
     * @param {string} id 
     * @param {CategoryUpdate} categoryUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryUpdateCategory(id: string, categoryUpdate: CategoryUpdate, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryUpdateCategory(id, categoryUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InventoryApi - axios parameter creator
 * @export
 */
export const InventoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary    
         * @param {InventoryCreate} inventoryCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryCreateInventory: async (inventoryCreate: InventoryCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryCreate' is not null or undefined
            assertParamExists('inventoryCreateInventory', 'inventoryCreate', inventoryCreate)
            const localVarPath = `/api/v1/inventory/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inventoryCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID    
         * @summary Delete Inventory
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryDeleteInventory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('inventoryDeleteInventory', 'id', id)
            const localVarPath = `/api/v1/inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Inventory
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryListInventory: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/inventory/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID    
         * @summary Read Inventory
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryReadInventory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('inventoryReadInventory', 'id', id)
            const localVarPath = `/api/v1/inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID    
         * @summary Update Inventory
         * @param {string} id 
         * @param {InventoryCreate} inventoryCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryUpdateInventory: async (id: string, inventoryCreate: InventoryCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('inventoryUpdateInventory', 'id', id)
            // verify required parameter 'inventoryCreate' is not null or undefined
            assertParamExists('inventoryUpdateInventory', 'inventoryCreate', inventoryCreate)
            const localVarPath = `/api/v1/inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inventoryCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary    
         * @param {InventoryCreate} inventoryCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryCreateInventory(inventoryCreate: InventoryCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryCreateInventory(inventoryCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryCreateInventory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID    
         * @summary Delete Inventory
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryDeleteInventory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryDeleteInventory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryDeleteInventory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Inventory
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryListInventory(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryListInventory(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryListInventory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID    
         * @summary Read Inventory
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryReadInventory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryReadInventory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryReadInventory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID    
         * @summary Update Inventory
         * @param {string} id 
         * @param {InventoryCreate} inventoryCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryUpdateInventory(id: string, inventoryCreate: InventoryCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryUpdateInventory(id, inventoryCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryUpdateInventory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoryApiFp(configuration)
    return {
        /**
         * 
         * @summary    
         * @param {InventoryCreate} inventoryCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryCreateInventory(inventoryCreate: InventoryCreate, options?: RawAxiosRequestConfig): AxiosPromise<InventoryPublic> {
            return localVarFp.inventoryCreateInventory(inventoryCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * ID    
         * @summary Delete Inventory
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryDeleteInventory(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.inventoryDeleteInventory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Inventory
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryListInventory(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<InventoryPublic>> {
            return localVarFp.inventoryListInventory(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * ID    
         * @summary Read Inventory
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryReadInventory(id: string, options?: RawAxiosRequestConfig): AxiosPromise<InventoryPublic> {
            return localVarFp.inventoryReadInventory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ID    
         * @summary Update Inventory
         * @param {string} id 
         * @param {InventoryCreate} inventoryCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryUpdateInventory(id: string, inventoryCreate: InventoryCreate, options?: RawAxiosRequestConfig): AxiosPromise<InventoryPublic> {
            return localVarFp.inventoryUpdateInventory(id, inventoryCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
    /**
     * 
     * @summary    
     * @param {InventoryCreate} inventoryCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public inventoryCreateInventory(inventoryCreate: InventoryCreate, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryCreateInventory(inventoryCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID    
     * @summary Delete Inventory
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public inventoryDeleteInventory(id: string, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryDeleteInventory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Inventory
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public inventoryListInventory(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryListInventory(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID    
     * @summary Read Inventory
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public inventoryReadInventory(id: string, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryReadInventory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID    
     * @summary Update Inventory
     * @param {string} id 
     * @param {InventoryCreate} inventoryCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public inventoryUpdateInventory(id: string, inventoryCreate: InventoryCreate, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryUpdateInventory(id, inventoryCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ListingApi - axios parameter creator
 * @export
 */
export const ListingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary  
         * @param {ListingCreate} listingCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingCreateListing: async (listingCreate: ListingCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listingCreate' is not null or undefined
            assertParamExists('listingCreateListing', 'listingCreate', listingCreate)
            const localVarPath = `/api/v1/listings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listingCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID  
         * @summary Delete Listing
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingDeleteListing: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listingDeleteListing', 'id', id)
            const localVarPath = `/api/v1/listings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *   
         * @summary List Listings
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingListListings: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/listings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID  
         * @summary Read Listing
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingReadListing: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listingReadListing', 'id', id)
            const localVarPath = `/api/v1/listings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID   
         * @summary Update Listing
         * @param {string} id 
         * @param {ListingCreate} listingCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingUpdateListing: async (id: string, listingCreate: ListingCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listingUpdateListing', 'id', id)
            // verify required parameter 'listingCreate' is not null or undefined
            assertParamExists('listingUpdateListing', 'listingCreate', listingCreate)
            const localVarPath = `/api/v1/listings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listingCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListingApi - functional programming interface
 * @export
 */
export const ListingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary  
         * @param {ListingCreate} listingCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingCreateListing(listingCreate: ListingCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingCreateListing(listingCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingApi.listingCreateListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID  
         * @summary Delete Listing
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingDeleteListing(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingDeleteListing(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingApi.listingDeleteListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *   
         * @summary List Listings
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingListListings(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListingPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingListListings(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingApi.listingListListings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID  
         * @summary Read Listing
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingReadListing(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingReadListing(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingApi.listingReadListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID   
         * @summary Update Listing
         * @param {string} id 
         * @param {ListingCreate} listingCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingUpdateListing(id: string, listingCreate: ListingCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingUpdateListing(id, listingCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingApi.listingUpdateListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ListingApi - factory interface
 * @export
 */
export const ListingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListingApiFp(configuration)
    return {
        /**
         * 
         * @summary  
         * @param {ListingCreate} listingCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingCreateListing(listingCreate: ListingCreate, options?: RawAxiosRequestConfig): AxiosPromise<ListingPublic> {
            return localVarFp.listingCreateListing(listingCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * ID  
         * @summary Delete Listing
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingDeleteListing(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listingDeleteListing(id, options).then((request) => request(axios, basePath));
        },
        /**
         *   
         * @summary List Listings
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingListListings(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListingPublic>> {
            return localVarFp.listingListListings(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * ID  
         * @summary Read Listing
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingReadListing(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ListingPublic> {
            return localVarFp.listingReadListing(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ID   
         * @summary Update Listing
         * @param {string} id 
         * @param {ListingCreate} listingCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingUpdateListing(id: string, listingCreate: ListingCreate, options?: RawAxiosRequestConfig): AxiosPromise<ListingPublic> {
            return localVarFp.listingUpdateListing(id, listingCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListingApi - object-oriented interface
 * @export
 * @class ListingApi
 * @extends {BaseAPI}
 */
export class ListingApi extends BaseAPI {
    /**
     * 
     * @summary  
     * @param {ListingCreate} listingCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingApi
     */
    public listingCreateListing(listingCreate: ListingCreate, options?: RawAxiosRequestConfig) {
        return ListingApiFp(this.configuration).listingCreateListing(listingCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID  
     * @summary Delete Listing
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingApi
     */
    public listingDeleteListing(id: string, options?: RawAxiosRequestConfig) {
        return ListingApiFp(this.configuration).listingDeleteListing(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *   
     * @summary List Listings
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingApi
     */
    public listingListListings(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ListingApiFp(this.configuration).listingListListings(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID  
     * @summary Read Listing
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingApi
     */
    public listingReadListing(id: string, options?: RawAxiosRequestConfig) {
        return ListingApiFp(this.configuration).listingReadListing(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID   
     * @summary Update Listing
     * @param {string} id 
     * @param {ListingCreate} listingCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingApi
     */
    public listingUpdateListing(id: string, listingCreate: ListingCreate, options?: RawAxiosRequestConfig) {
        return ListingApiFp(this.configuration).listingUpdateListing(id, listingCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarketApi - axios parameter creator
 * @export
 */
export const MarketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Market
         * @param {MarketPlaceCreate} marketPlaceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketCreateMarket: async (marketPlaceCreate: MarketPlaceCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketPlaceCreate' is not null or undefined
            assertParamExists('marketCreateMarket', 'marketPlaceCreate', marketPlaceCreate)
            const localVarPath = `/api/v1/markets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(marketPlaceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Market
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDeleteMarket: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('marketDeleteMarket', 'id', id)
            const localVarPath = `/api/v1/markets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Markets
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketListMarkets: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/markets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Market
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketReadMarket: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('marketReadMarket', 'id', id)
            const localVarPath = `/api/v1/markets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Market
         * @param {string} id 
         * @param {MarketPlaceUpdate} marketPlaceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketUpdateMarket: async (id: string, marketPlaceUpdate: MarketPlaceUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('marketUpdateMarket', 'id', id)
            // verify required parameter 'marketPlaceUpdate' is not null or undefined
            assertParamExists('marketUpdateMarket', 'marketPlaceUpdate', marketPlaceUpdate)
            const localVarPath = `/api/v1/markets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(marketPlaceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketApi - functional programming interface
 * @export
 */
export const MarketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Market
         * @param {MarketPlaceCreate} marketPlaceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketCreateMarket(marketPlaceCreate: MarketPlaceCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketPlacePublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketCreateMarket(marketPlaceCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.marketCreateMarket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Market
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketDeleteMarket(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketDeleteMarket(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.marketDeleteMarket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Markets
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketListMarkets(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MarketPlacePublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketListMarkets(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.marketListMarkets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Market
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketReadMarket(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketPlacePublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketReadMarket(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.marketReadMarket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Market
         * @param {string} id 
         * @param {MarketPlaceUpdate} marketPlaceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketUpdateMarket(id: string, marketPlaceUpdate: MarketPlaceUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketPlacePublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketUpdateMarket(id, marketPlaceUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.marketUpdateMarket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketApi - factory interface
 * @export
 */
export const MarketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Market
         * @param {MarketPlaceCreate} marketPlaceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketCreateMarket(marketPlaceCreate: MarketPlaceCreate, options?: RawAxiosRequestConfig): AxiosPromise<MarketPlacePublic> {
            return localVarFp.marketCreateMarket(marketPlaceCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Market
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDeleteMarket(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.marketDeleteMarket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Markets
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketListMarkets(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MarketPlacePublic>> {
            return localVarFp.marketListMarkets(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Market
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketReadMarket(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MarketPlacePublic> {
            return localVarFp.marketReadMarket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Market
         * @param {string} id 
         * @param {MarketPlaceUpdate} marketPlaceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketUpdateMarket(id: string, marketPlaceUpdate: MarketPlaceUpdate, options?: RawAxiosRequestConfig): AxiosPromise<MarketPlacePublic> {
            return localVarFp.marketUpdateMarket(id, marketPlaceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketApi - object-oriented interface
 * @export
 * @class MarketApi
 * @extends {BaseAPI}
 */
export class MarketApi extends BaseAPI {
    /**
     * 
     * @summary Create Market
     * @param {MarketPlaceCreate} marketPlaceCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public marketCreateMarket(marketPlaceCreate: MarketPlaceCreate, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).marketCreateMarket(marketPlaceCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Market
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public marketDeleteMarket(id: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).marketDeleteMarket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Markets
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public marketListMarkets(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).marketListMarkets(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Market
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public marketReadMarket(id: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).marketReadMarket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Market
     * @param {string} id 
     * @param {MarketPlaceUpdate} marketPlaceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public marketUpdateMarket(id: string, marketPlaceUpdate: MarketPlaceUpdate, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).marketUpdateMarket(id, marketPlaceUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary  
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaDeleteMedia: async (mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('mediaDeleteMedia', 'mediaId', mediaId)
            const localVarPath = `/api/v1/media-assets/{media_id}`
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary   
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaReadMedia: async (mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('mediaReadMedia', 'mediaId', mediaId)
            const localVarPath = `/api/v1/media-assets/{media_id}`
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /   MediaAsset 
         * @param {MediaAssetCreate} mediaAssetCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaUploadMedia: async (mediaAssetCreate: MediaAssetCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaAssetCreate' is not null or undefined
            assertParamExists('mediaUploadMedia', 'mediaAssetCreate', mediaAssetCreate)
            const localVarPath = `/api/v1/media-assets/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaAssetCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary  
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaDeleteMedia(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaDeleteMedia(mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaDeleteMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary   
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaReadMedia(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaAssetPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaReadMedia(mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaReadMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary /   MediaAsset 
         * @param {MediaAssetCreate} mediaAssetCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaUploadMedia(mediaAssetCreate: MediaAssetCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaAssetPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaUploadMedia(mediaAssetCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaUploadMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @summary  
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaDeleteMedia(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.mediaDeleteMedia(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary   
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaReadMedia(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaAssetPublic> {
            return localVarFp.mediaReadMedia(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /   MediaAsset 
         * @param {MediaAssetCreate} mediaAssetCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaUploadMedia(mediaAssetCreate: MediaAssetCreate, options?: RawAxiosRequestConfig): AxiosPromise<MediaAssetPublic> {
            return localVarFp.mediaUploadMedia(mediaAssetCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * 
     * @summary  
     * @param {string} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaDeleteMedia(mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaDeleteMedia(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary   
     * @param {string} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaReadMedia(mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaReadMedia(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /   MediaAsset 
     * @param {MediaAssetCreate} mediaAssetCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaUploadMedia(mediaAssetCreate: MediaAssetCreate, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaUploadMedia(mediaAssetCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Product
         * @param {ProductCreate} productCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCreateProduct: async (productCreate: ProductCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productCreate' is not null or undefined
            assertParamExists('productCreateProduct', 'productCreate', productCreate)
            const localVarPath = `/api/v1/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Product
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productDeleteProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productDeleteProduct', 'id', id)
            const localVarPath = `/api/v1/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string} [categoryName] 
         * @param {string} [brandName] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productListProducts: async (categoryName?: string, brandName?: string, skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (categoryName !== undefined) {
                localVarQueryParameter['category_name'] = categoryName;
            }

            if (brandName !== undefined) {
                localVarQueryParameter['brand_name'] = brandName;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Product
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReadProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productReadProduct', 'id', id)
            const localVarPath = `/api/v1/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Product
         * @param {string} id 
         * @param {ProductUpdate} productUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUpdateProduct: async (id: string, productUpdate: ProductUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productUpdateProduct', 'id', id)
            // verify required parameter 'productUpdate' is not null or undefined
            assertParamExists('productUpdateProduct', 'productUpdate', productUpdate)
            const localVarPath = `/api/v1/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Product
         * @param {ProductCreate} productCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCreateProduct(productCreate: ProductCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCreateProduct(productCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productCreateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Product
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productDeleteProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productDeleteProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productDeleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Products
         * @param {string} [categoryName] 
         * @param {string} [brandName] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productListProducts(categoryName?: string, brandName?: string, skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productListProducts(categoryName, brandName, skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productListProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Product
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReadProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReadProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productReadProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Product
         * @param {string} id 
         * @param {ProductUpdate} productUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUpdateProduct(id: string, productUpdate: ProductUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUpdateProduct(id, productUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productUpdateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Product
         * @param {ProductCreate} productCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCreateProduct(productCreate: ProductCreate, options?: RawAxiosRequestConfig): AxiosPromise<ProductPublic> {
            return localVarFp.productCreateProduct(productCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Product
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productDeleteProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.productDeleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Products
         * @param {string} [categoryName] 
         * @param {string} [brandName] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productListProducts(categoryName?: string, brandName?: string, skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductPublic>> {
            return localVarFp.productListProducts(categoryName, brandName, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Product
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReadProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductPublic> {
            return localVarFp.productReadProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Product
         * @param {string} id 
         * @param {ProductUpdate} productUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUpdateProduct(id: string, productUpdate: ProductUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ProductPublic> {
            return localVarFp.productUpdateProduct(id, productUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary Create Product
     * @param {ProductCreate} productCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productCreateProduct(productCreate: ProductCreate, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productCreateProduct(productCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Product
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productDeleteProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productDeleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Products
     * @param {string} [categoryName] 
     * @param {string} [brandName] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productListProducts(categoryName?: string, brandName?: string, skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productListProducts(categoryName, brandName, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Product
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productReadProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productReadProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Product
     * @param {string} id 
     * @param {ProductUpdate} productUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productUpdateProduct(id: string, productUpdate: ProductUpdate, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productUpdateProduct(id, productUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RankingApi - axios parameter creator
 * @export
 */
export const RankingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Ranking
         * @param {string} rankingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingDeleteRanking: async (rankingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rankingId' is not null or undefined
            assertParamExists('rankingDeleteRanking', 'rankingId', rankingId)
            const localVarPath = `/api/v1/rankings/{ranking_id}`
                .replace(`{${"ranking_id"}}`, encodeURIComponent(String(rankingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Excel  
         * @param {string} rankingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingDownloadRanking: async (rankingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rankingId' is not null or undefined
            assertParamExists('rankingDownloadRanking', 'rankingId', rankingId)
            const localVarPath = `/api/v1/rankings/download/{ranking_id}`
                .replace(`{${"ranking_id"}}`, encodeURIComponent(String(rankingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Today Rankings
         * @param {string} category 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetTodayRankings: async (category: string, skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('rankingGetTodayRankings', 'category', category)
            const localVarPath = `/api/v1/rankings/today/{category}`
                .replace(`{${"category"}}`, encodeURIComponent(String(category)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Rankings
         * @param {string | null} [category] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingListRankings: async (category?: string | null, skip?: number, limit?: number, sortBy?: string, sortOrder?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/rankings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Ranking Snapshot
         * @param {string} rankingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingReadRankingSnapshot: async (rankingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rankingId' is not null or undefined
            assertParamExists('rankingReadRankingSnapshot', 'rankingId', rankingId)
            const localVarPath = `/api/v1/rankings/{ranking_id}`
                .replace(`{${"ranking_id"}}`, encodeURIComponent(String(rankingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Scrape And Return
         * @param {string} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingScrapeAndReturn: async (category: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('rankingScrapeAndReturn', 'category', category)
            const localVarPath = `/api/v1/rankings/scrape/{category}`
                .replace(`{${"category"}}`, encodeURIComponent(String(category)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RankingApi - functional programming interface
 * @export
 */
export const RankingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RankingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Ranking
         * @param {string} rankingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingDeleteRanking(rankingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingDeleteRanking(rankingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RankingApi.rankingDeleteRanking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary  Excel  
         * @param {string} rankingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingDownloadRanking(rankingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingDownloadRanking(rankingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RankingApi.rankingDownloadRanking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Today Rankings
         * @param {string} category 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingGetTodayRankings(category: string, skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingSnapshotPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingGetTodayRankings(category, skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RankingApi.rankingGetTodayRankings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Rankings
         * @param {string | null} [category] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingListRankings(category?: string | null, skip?: number, limit?: number, sortBy?: string, sortOrder?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingListRankings(category, skip, limit, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RankingApi.rankingListRankings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Ranking Snapshot
         * @param {string} rankingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingReadRankingSnapshot(rankingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RankingSnapshotPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingReadRankingSnapshot(rankingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RankingApi.rankingReadRankingSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Scrape And Return
         * @param {string} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingScrapeAndReturn(category: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RankingSnapshotPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingScrapeAndReturn(category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RankingApi.rankingScrapeAndReturn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RankingApi - factory interface
 * @export
 */
export const RankingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RankingApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Ranking
         * @param {string} rankingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingDeleteRanking(rankingId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.rankingDeleteRanking(rankingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary  Excel  
         * @param {string} rankingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingDownloadRanking(rankingId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rankingDownloadRanking(rankingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Today Rankings
         * @param {string} category 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetTodayRankings(category: string, skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingSnapshotPublic>> {
            return localVarFp.rankingGetTodayRankings(category, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Rankings
         * @param {string | null} [category] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingListRankings(category?: string | null, skip?: number, limit?: number, sortBy?: string, sortOrder?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingPublic>> {
            return localVarFp.rankingListRankings(category, skip, limit, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Ranking Snapshot
         * @param {string} rankingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingReadRankingSnapshot(rankingId: string, options?: RawAxiosRequestConfig): AxiosPromise<RankingSnapshotPublic> {
            return localVarFp.rankingReadRankingSnapshot(rankingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Scrape And Return
         * @param {string} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingScrapeAndReturn(category: string, options?: RawAxiosRequestConfig): AxiosPromise<RankingSnapshotPublic> {
            return localVarFp.rankingScrapeAndReturn(category, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RankingApi - object-oriented interface
 * @export
 * @class RankingApi
 * @extends {BaseAPI}
 */
export class RankingApi extends BaseAPI {
    /**
     * 
     * @summary Delete Ranking
     * @param {string} rankingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingDeleteRanking(rankingId: string, options?: RawAxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingDeleteRanking(rankingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary  Excel  
     * @param {string} rankingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingDownloadRanking(rankingId: string, options?: RawAxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingDownloadRanking(rankingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Today Rankings
     * @param {string} category 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingGetTodayRankings(category: string, skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingGetTodayRankings(category, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Rankings
     * @param {string | null} [category] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [sortBy] 
     * @param {string} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingListRankings(category?: string | null, skip?: number, limit?: number, sortBy?: string, sortOrder?: string, options?: RawAxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingListRankings(category, skip, limit, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Ranking Snapshot
     * @param {string} rankingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingReadRankingSnapshot(rankingId: string, options?: RawAxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingReadRankingSnapshot(rankingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Scrape And Return
     * @param {string} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingScrapeAndReturn(category: string, options?: RawAxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingScrapeAndReturn(category, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariantApi - axios parameter creator
 * @export
 */
export const VariantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary   
         * @param {VariantCreate} variantCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantCreateVariant: async (variantCreate: VariantCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantCreate' is not null or undefined
            assertParamExists('variantCreateVariant', 'variantCreate', variantCreate)
            const localVarPath = `/api/v1/variants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variantCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID   
         * @summary Delete Variant
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantDeleteVariant: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('variantDeleteVariant', 'id', id)
            const localVarPath = `/api/v1/variants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Variants
         * @param {string} [productId] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantListVariants: async (productId?: string, skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/variants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Variant
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantReadVariant: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('variantReadVariant', 'id', id)
            const localVarPath = `/api/v1/variants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Variant By Barcode
         * @param {string} barcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantSearchVariantByBarcode: async (barcode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('variantSearchVariantByBarcode', 'barcode', barcode)
            const localVarPath = `/api/v1/variants/{barcode}`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Variant
         * @param {string} id 
         * @param {VariantUpdate} variantUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantUpdateVariant: async (id: string, variantUpdate: VariantUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('variantUpdateVariant', 'id', id)
            // verify required parameter 'variantUpdate' is not null or undefined
            assertParamExists('variantUpdateVariant', 'variantUpdate', variantUpdate)
            const localVarPath = `/api/v1/variants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variantUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariantApi - functional programming interface
 * @export
 */
export const VariantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary   
         * @param {VariantCreate} variantCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantCreateVariant(variantCreate: VariantCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantCreateVariant(variantCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.variantCreateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID   
         * @summary Delete Variant
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantDeleteVariant(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantDeleteVariant(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.variantDeleteVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Variants
         * @param {string} [productId] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantListVariants(productId?: string, skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariantPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantListVariants(productId, skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.variantListVariants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Variant
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantReadVariant(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantReadVariant(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.variantReadVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Variant By Barcode
         * @param {string} barcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantSearchVariantByBarcode(barcode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantSearchVariantByBarcode(barcode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.variantSearchVariantByBarcode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Variant
         * @param {string} id 
         * @param {VariantUpdate} variantUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantUpdateVariant(id: string, variantUpdate: VariantUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantUpdateVariant(id, variantUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.variantUpdateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariantApi - factory interface
 * @export
 */
export const VariantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariantApiFp(configuration)
    return {
        /**
         * 
         * @summary   
         * @param {VariantCreate} variantCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantCreateVariant(variantCreate: VariantCreate, options?: RawAxiosRequestConfig): AxiosPromise<VariantPublic> {
            return localVarFp.variantCreateVariant(variantCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * ID   
         * @summary Delete Variant
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantDeleteVariant(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.variantDeleteVariant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Variants
         * @param {string} [productId] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantListVariants(productId?: string, skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariantPublic>> {
            return localVarFp.variantListVariants(productId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Variant
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantReadVariant(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantPublic> {
            return localVarFp.variantReadVariant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Variant By Barcode
         * @param {string} barcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantSearchVariantByBarcode(barcode: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantPublic> {
            return localVarFp.variantSearchVariantByBarcode(barcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Variant
         * @param {string} id 
         * @param {VariantUpdate} variantUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantUpdateVariant(id: string, variantUpdate: VariantUpdate, options?: RawAxiosRequestConfig): AxiosPromise<VariantPublic> {
            return localVarFp.variantUpdateVariant(id, variantUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariantApi - object-oriented interface
 * @export
 * @class VariantApi
 * @extends {BaseAPI}
 */
export class VariantApi extends BaseAPI {
    /**
     * 
     * @summary   
     * @param {VariantCreate} variantCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public variantCreateVariant(variantCreate: VariantCreate, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).variantCreateVariant(variantCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID   
     * @summary Delete Variant
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public variantDeleteVariant(id: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).variantDeleteVariant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Variants
     * @param {string} [productId] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public variantListVariants(productId?: string, skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).variantListVariants(productId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Variant
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public variantReadVariant(id: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).variantReadVariant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Variant By Barcode
     * @param {string} barcode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public variantSearchVariantByBarcode(barcode: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).variantSearchVariantByBarcode(barcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Variant
     * @param {string} id 
     * @param {VariantUpdate} variantUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public variantUpdateVariant(id: string, variantUpdate: VariantUpdate, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).variantUpdateVariant(id, variantUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



