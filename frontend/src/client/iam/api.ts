/* tslint:disable */
/* eslint-disable */
/**
 * JulyLand - IAM [dev]
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdminUserCreate
 */
export interface AdminUserCreate {
    /**
     * 
     * @type {string}
     * @memberof AdminUserCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdminUserCreate
     */
    'fullname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminUserCreate
     */
    'provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminUserCreate
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminUserCreate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdminUserCreate
     */
    'is_superuser'?: boolean;
}
/**
 * 
 * @export
 * @interface AdminUserUpdate
 */
export interface AdminUserUpdate {
    /**
     * 
     * @type {string}
     * @memberof AdminUserUpdate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminUserUpdate
     */
    'fullname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminUserUpdate
     */
    'password'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AdminUserUpdate
     */
    'is_active'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AdminUserUpdate
     */
    'is_superuser'?: boolean | null;
}
/**
 * 서비스 생성 요청
 * @export
 * @interface AppCreate
 */
export interface AppCreate {
    /**
     * 
     * @type {string}
     * @memberof AppCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AppCreate
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppCreate
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AppPublic
 */
export interface AppPublic {
    /**
     * 
     * @type {string}
     * @memberof AppPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof AppPublic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AppPublic
     */
    'logo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AppPublic
     */
    'description'?: string | null;
}
/**
 * 서비스 업데이트 요청
 * @export
 * @interface AppUpdate
 */
export interface AppUpdate {
    /**
     * 
     * @type {string}
     * @memberof AppUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AppUpdate
     */
    'logo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AppUpdate
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface NewPassword
 */
export interface NewPassword {
    /**
     * 
     * @type {string}
     * @memberof NewPassword
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof NewPassword
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface OAuthAccount
 */
export interface OAuthAccount {
    /**
     * 
     * @type {string}
     * @memberof OAuthAccount
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthAccount
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthAccount
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthAccount
     */
    'oauth_name': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthAccount
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthAccount
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthAccount
     */
    'account_email': string;
    /**
     * 
     * @type {number}
     * @memberof OAuthAccount
     */
    'expired_in'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OAuthAccount
     */
    'expires_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OAuthAccount
     */
    'refresh_token'?: string | null;
}
/**
 * 구독 생성 요청
 * @export
 * @interface SubscriptionCreate
 */
export interface SubscriptionCreate {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'app_id': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'tier': string;
    /**
     * 
     * @type {SubscriptionStatus}
     * @memberof SubscriptionCreate
     */
    'status'?: SubscriptionStatus;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionCreate
     */
    'duration_days': number;
}


/**
 * 구독 정보 응답
 * @export
 * @interface SubscriptionPublic
 */
export interface SubscriptionPublic {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPublic
     */
    '_id': string;
    /**
     * 
     * @type {UserPublic}
     * @memberof SubscriptionPublic
     */
    'user': UserPublic;
    /**
     * 
     * @type {AppPublic}
     * @memberof SubscriptionPublic
     */
    'app': AppPublic;
    /**
     * 
     * @type {SubscriptionStatus}
     * @memberof SubscriptionPublic
     */
    'status': SubscriptionStatus;
    /**
     * 
     * @type {SubscriptionTier}
     * @memberof SubscriptionPublic
     */
    'tier': SubscriptionTier;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPublic
     */
    'expires_at': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SubscriptionStatus = {
    Active: 'active',
    Trial: 'trial',
    Canceled: 'canceled',
    Expired: 'expired',
    None: 'none'
} as const;

export type SubscriptionStatus = typeof SubscriptionStatus[keyof typeof SubscriptionStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const SubscriptionTier = {
    Free: 'free',
    Basic: 'basic',
    Premium: 'premium',
    Enterprise: 'enterprise'
} as const;

export type SubscriptionTier = typeof SubscriptionTier[keyof typeof SubscriptionTier];


/**
 * 구독 업데이트 요청
 * @export
 * @interface SubscriptionUpdate
 */
export interface SubscriptionUpdate {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUpdate
     */
    'app_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUpdate
     */
    'tier': string | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUpdate
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {SubscriptionStatus}
     * @memberof SubscriptionUpdate
     */
    'status': SubscriptionStatus | null;
}


/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'refresh_token': string | null;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'token_type': string;
}
/**
 * 본인 비밀번호 변경을 위한 모델
 * @export
 * @interface UpdatePassword
 */
export interface UpdatePassword {
    /**
     * 
     * @type {string}
     * @memberof UpdatePassword
     */
    'current_password': string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePassword
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface UserPublic
 */
export interface UserPublic {
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    'fullname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    'provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    'avatar_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    'mobile_phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPublic
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPublic
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPublic
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    'last_login_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserPublic
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<OAuthAccount>}
     * @memberof UserPublic
     */
    'oauth_accounts'?: Array<OAuthAccount> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPublic
     */
    'apps'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface UserRegister
 */
export interface UserRegister {
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'fullname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRegister
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRegister
     */
    'is_superuser'?: boolean;
}
/**
 * 
 * @export
 * @interface UserSearchPublic
 */
export interface UserSearchPublic {
    /**
     * 
     * @type {string}
     * @memberof UserSearchPublic
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserSearchPublic
     */
    'fullname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSearchPublic
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UserUpdateMe
 */
export interface UserUpdateMe {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateMe
     */
    'fullname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateMe
     */
    'avatar_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateMe
     */
    'mobile_phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateMe
     */
    'birthday'?: string | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * [관리자 전용] 서비스 생성
         * @summary Create App
         * @param {AppCreate} appCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateApp: async (appCreate: AppCreate, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appCreate' is not null or undefined
            assertParamExists('adminCreateApp', 'appCreate', appCreate)
            const localVarPath = `/api/v1/admin/apps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [관리자 전용] 특정 사용자의 구독 생성
         * @summary Create Subscription
         * @param {SubscriptionCreate} subscriptionCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateSubscription: async (subscriptionCreate: SubscriptionCreate, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionCreate' is not null or undefined
            assertParamExists('adminCreateSubscription', 'subscriptionCreate', subscriptionCreate)
            const localVarPath = `/api/v1/admin/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [관리자 전용] 사용자 생성
         * @summary Create User
         * @param {AdminUserCreate} adminUserCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser: async (adminUserCreate: AdminUserCreate, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUserCreate' is not null or undefined
            assertParamExists('adminCreateUser', 'adminUserCreate', adminUserCreate)
            const localVarPath = `/api/v1/admin/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUserCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [관리자 전용] 서비스 삭제
         * @summary Delete App
         * @param {string} appId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteApp: async (appId: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('adminDeleteApp', 'appId', appId)
            const localVarPath = `/api/v1/admin/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [관리자 전용] 특정 사용자의 구독 삭제
         * @summary Delete Subscription
         * @param {string} subscriptionId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteSubscription: async (subscriptionId: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('adminDeleteSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/v1/admin/subscriptions/{subscription_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자 삭제
         * @summary Delete User
         * @param {string} userId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser: async (userId: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminDeleteUser', 'userId', userId)
            const localVarPath = `/api/v1/admin/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 서비스 정보 조회
         * @summary Read App By Id
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadAppById: async (appId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('adminReadAppById', 'appId', appId)
            const localVarPath = `/api/v1/admin/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 App의 상세 정보를 조회합니다.  :param name: 조회할 App의 ObjectId :return: AppPublic 객체 :raises HTTPException: App을 찾지 못한 경우 (404)
         * @summary [관리자]특정 App 조회
         * @param {string} appName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadAppByName: async (appName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appName' is not null or undefined
            assertParamExists('adminReadAppByName', 'appName', appName)
            const localVarPath = `/api/v1/admin/apps/{app_name}`
                .replace(`{${"app_name"}}`, encodeURIComponent(String(appName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [관리자 전용] 서비스 목록 조회
         * @summary Read Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadApps: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admin/apps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [관리자 전용] 모든 구독 조회 (또는 특정 사용자 구독 조회)
         * @summary Read Subscriptions
         * @param {string | null} [userId] 
         * @param {string | null} [appName] 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadSubscriptions: async (userId?: string | null, appName?: string | null, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admin/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (appName !== undefined) {
                localVarQueryParameter['app_name'] = appName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 사용자 정보 조회
         * @summary Read User By Id
         * @param {string} userId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadUserById: async (userId: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminReadUserById', 'userId', userId)
            const localVarPath = `/api/v1/admin/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [관리자 전용] 사용자 조회
         * @summary Read Users
         * @param {string | null} [appName] 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadUsers: async (appName?: string | null, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admin/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (appName !== undefined) {
                localVarQueryParameter['app_name'] = appName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [관리자 전용] 서비스 정보 수정
         * @summary Update App
         * @param {string} appId 
         * @param {AppUpdate} appUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateApp: async (appId: string, appUpdate: AppUpdate, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('adminUpdateApp', 'appId', appId)
            // verify required parameter 'appUpdate' is not null or undefined
            assertParamExists('adminUpdateApp', 'appUpdate', appUpdate)
            const localVarPath = `/api/v1/admin/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [관리자 전용] 특정 사용자의 구독 수정
         * @summary Update Subscription
         * @param {string} subscriptionId 
         * @param {SubscriptionUpdate} subscriptionUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateSubscription: async (subscriptionId: string, subscriptionUpdate: SubscriptionUpdate, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('adminUpdateSubscription', 'subscriptionId', subscriptionId)
            // verify required parameter 'subscriptionUpdate' is not null or undefined
            assertParamExists('adminUpdateSubscription', 'subscriptionUpdate', subscriptionUpdate)
            const localVarPath = `/api/v1/admin/subscriptions/{subscription_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자 정보 업데이트
         * @summary Update User
         * @param {string} userId 
         * @param {AdminUserUpdate} adminUserUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser: async (userId: string, adminUserUpdate: AdminUserUpdate, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUpdateUser', 'userId', userId)
            // verify required parameter 'adminUserUpdate' is not null or undefined
            assertParamExists('adminUpdateUser', 'adminUserUpdate', adminUserUpdate)
            const localVarPath = `/api/v1/admin/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUserUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * [관리자 전용] 서비스 생성
         * @summary Create App
         * @param {AppCreate} appCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateApp(appCreate: AppCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateApp(appCreate, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [관리자 전용] 특정 사용자의 구독 생성
         * @summary Create Subscription
         * @param {SubscriptionCreate} subscriptionCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateSubscription(subscriptionCreate: SubscriptionCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateSubscription(subscriptionCreate, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [관리자 전용] 사용자 생성
         * @summary Create User
         * @param {AdminUserCreate} adminUserCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateUser(adminUserCreate: AdminUserCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateUser(adminUserCreate, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [관리자 전용] 서비스 삭제
         * @summary Delete App
         * @param {string} appId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteApp(appId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteApp(appId, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [관리자 전용] 특정 사용자의 구독 삭제
         * @summary Delete Subscription
         * @param {string} subscriptionId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteSubscription(subscriptionId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteSubscription(subscriptionId, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자 삭제
         * @summary Delete User
         * @param {string} userId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUser(userId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUser(userId, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 서비스 정보 조회
         * @summary Read App By Id
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminReadAppById(appId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminReadAppById(appId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminReadAppById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 App의 상세 정보를 조회합니다.  :param name: 조회할 App의 ObjectId :return: AppPublic 객체 :raises HTTPException: App을 찾지 못한 경우 (404)
         * @summary [관리자]특정 App 조회
         * @param {string} appName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminReadAppByName(appName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminReadAppByName(appName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminReadAppByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [관리자 전용] 서비스 목록 조회
         * @summary Read Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminReadApps(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminReadApps(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminReadApps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [관리자 전용] 모든 구독 조회 (또는 특정 사용자 구독 조회)
         * @summary Read Subscriptions
         * @param {string | null} [userId] 
         * @param {string | null} [appName] 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminReadSubscriptions(userId?: string | null, appName?: string | null, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminReadSubscriptions(userId, appName, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminReadSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 사용자 정보 조회
         * @summary Read User By Id
         * @param {string} userId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminReadUserById(userId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminReadUserById(userId, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminReadUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [관리자 전용] 사용자 조회
         * @summary Read Users
         * @param {string | null} [appName] 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminReadUsers(appName?: string | null, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminReadUsers(appName, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminReadUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [관리자 전용] 서비스 정보 수정
         * @summary Update App
         * @param {string} appId 
         * @param {AppUpdate} appUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateApp(appId: string, appUpdate: AppUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateApp(appId, appUpdate, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [관리자 전용] 특정 사용자의 구독 수정
         * @summary Update Subscription
         * @param {string} subscriptionId 
         * @param {SubscriptionUpdate} subscriptionUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateSubscription(subscriptionId: string, subscriptionUpdate: SubscriptionUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateSubscription(subscriptionId, subscriptionUpdate, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자 정보 업데이트
         * @summary Update User
         * @param {string} userId 
         * @param {AdminUserUpdate} adminUserUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUser(userId: string, adminUserUpdate: AdminUserUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(userId, adminUserUpdate, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * [관리자 전용] 서비스 생성
         * @summary Create App
         * @param {AppCreate} appCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateApp(appCreate: AppCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<AppPublic> {
            return localVarFp.adminCreateApp(appCreate, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * [관리자 전용] 특정 사용자의 구독 생성
         * @summary Create Subscription
         * @param {SubscriptionCreate} subscriptionCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateSubscription(subscriptionCreate: SubscriptionCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionPublic> {
            return localVarFp.adminCreateSubscription(subscriptionCreate, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * [관리자 전용] 사용자 생성
         * @summary Create User
         * @param {AdminUserCreate} adminUserCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser(adminUserCreate: AdminUserCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserPublic> {
            return localVarFp.adminCreateUser(adminUserCreate, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * [관리자 전용] 서비스 삭제
         * @summary Delete App
         * @param {string} appId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteApp(appId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.adminDeleteApp(appId, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * [관리자 전용] 특정 사용자의 구독 삭제
         * @summary Delete Subscription
         * @param {string} subscriptionId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteSubscription(subscriptionId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.adminDeleteSubscription(subscriptionId, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자 삭제
         * @summary Delete User
         * @param {string} userId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser(userId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.adminDeleteUser(userId, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 서비스 정보 조회
         * @summary Read App By Id
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadAppById(appId: string, options?: RawAxiosRequestConfig): AxiosPromise<AppPublic> {
            return localVarFp.adminReadAppById(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 App의 상세 정보를 조회합니다.  :param name: 조회할 App의 ObjectId :return: AppPublic 객체 :raises HTTPException: App을 찾지 못한 경우 (404)
         * @summary [관리자]특정 App 조회
         * @param {string} appName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadAppByName(appName: string, options?: RawAxiosRequestConfig): AxiosPromise<AppPublic> {
            return localVarFp.adminReadAppByName(appName, options).then((request) => request(axios, basePath));
        },
        /**
         * [관리자 전용] 서비스 목록 조회
         * @summary Read Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadApps(options?: RawAxiosRequestConfig): AxiosPromise<Array<AppPublic>> {
            return localVarFp.adminReadApps(options).then((request) => request(axios, basePath));
        },
        /**
         * [관리자 전용] 모든 구독 조회 (또는 특정 사용자 구독 조회)
         * @summary Read Subscriptions
         * @param {string | null} [userId] 
         * @param {string | null} [appName] 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadSubscriptions(userId?: string | null, appName?: string | null, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<SubscriptionPublic>> {
            return localVarFp.adminReadSubscriptions(userId, appName, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 사용자 정보 조회
         * @summary Read User By Id
         * @param {string} userId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadUserById(userId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserPublic> {
            return localVarFp.adminReadUserById(userId, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * [관리자 전용] 사용자 조회
         * @summary Read Users
         * @param {string | null} [appName] 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminReadUsers(appName?: string | null, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserPublic>> {
            return localVarFp.adminReadUsers(appName, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * [관리자 전용] 서비스 정보 수정
         * @summary Update App
         * @param {string} appId 
         * @param {AppUpdate} appUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateApp(appId: string, appUpdate: AppUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<AppPublic> {
            return localVarFp.adminUpdateApp(appId, appUpdate, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * [관리자 전용] 특정 사용자의 구독 수정
         * @summary Update Subscription
         * @param {string} subscriptionId 
         * @param {SubscriptionUpdate} subscriptionUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateSubscription(subscriptionId: string, subscriptionUpdate: SubscriptionUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionPublic> {
            return localVarFp.adminUpdateSubscription(subscriptionId, subscriptionUpdate, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자 정보 업데이트
         * @summary Update User
         * @param {string} userId 
         * @param {AdminUserUpdate} adminUserUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser(userId: string, adminUserUpdate: AdminUserUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserPublic> {
            return localVarFp.adminUpdateUser(userId, adminUserUpdate, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * [관리자 전용] 서비스 생성
     * @summary Create App
     * @param {AppCreate} appCreate 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateApp(appCreate: AppCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateApp(appCreate, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [관리자 전용] 특정 사용자의 구독 생성
     * @summary Create Subscription
     * @param {SubscriptionCreate} subscriptionCreate 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateSubscription(subscriptionCreate: SubscriptionCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateSubscription(subscriptionCreate, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [관리자 전용] 사용자 생성
     * @summary Create User
     * @param {AdminUserCreate} adminUserCreate 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateUser(adminUserCreate: AdminUserCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateUser(adminUserCreate, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [관리자 전용] 서비스 삭제
     * @summary Delete App
     * @param {string} appId 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteApp(appId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteApp(appId, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [관리자 전용] 특정 사용자의 구독 삭제
     * @summary Delete Subscription
     * @param {string} subscriptionId 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteSubscription(subscriptionId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteSubscription(subscriptionId, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자 삭제
     * @summary Delete User
     * @param {string} userId 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteUser(userId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteUser(userId, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 서비스 정보 조회
     * @summary Read App By Id
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminReadAppById(appId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminReadAppById(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 App의 상세 정보를 조회합니다.  :param name: 조회할 App의 ObjectId :return: AppPublic 객체 :raises HTTPException: App을 찾지 못한 경우 (404)
     * @summary [관리자]특정 App 조회
     * @param {string} appName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminReadAppByName(appName: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminReadAppByName(appName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [관리자 전용] 서비스 목록 조회
     * @summary Read Apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminReadApps(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminReadApps(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [관리자 전용] 모든 구독 조회 (또는 특정 사용자 구독 조회)
     * @summary Read Subscriptions
     * @param {string | null} [userId] 
     * @param {string | null} [appName] 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminReadSubscriptions(userId?: string | null, appName?: string | null, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminReadSubscriptions(userId, appName, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 사용자 정보 조회
     * @summary Read User By Id
     * @param {string} userId 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminReadUserById(userId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminReadUserById(userId, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [관리자 전용] 사용자 조회
     * @summary Read Users
     * @param {string | null} [appName] 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminReadUsers(appName?: string | null, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminReadUsers(appName, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [관리자 전용] 서비스 정보 수정
     * @summary Update App
     * @param {string} appId 
     * @param {AppUpdate} appUpdate 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateApp(appId: string, appUpdate: AppUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateApp(appId, appUpdate, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [관리자 전용] 특정 사용자의 구독 수정
     * @summary Update Subscription
     * @param {string} subscriptionId 
     * @param {SubscriptionUpdate} subscriptionUpdate 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateSubscription(subscriptionId: string, subscriptionUpdate: SubscriptionUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateSubscription(subscriptionId, subscriptionUpdate, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자 정보 업데이트
     * @summary Update User
     * @param {string} userId 
     * @param {AdminUserUpdate} adminUserUpdate 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateUser(userId: string, adminUserUpdate: AdminUserUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateUser(userId, adminUserUpdate, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AppsApi - axios parameter creator
 * @export
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * [관리자 전용] 서비스 조회
         * @summary Read Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsReadApps: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/apps/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsApiAxiosParamCreator(configuration)
    return {
        /**
         * [관리자 전용] 서비스 조회
         * @summary Read Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsReadApps(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsReadApps(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsReadApps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsApiFp(configuration)
    return {
        /**
         * [관리자 전용] 서비스 조회
         * @summary Read Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsReadApps(options?: RawAxiosRequestConfig): AxiosPromise<Array<AppPublic>> {
            return localVarFp.appsReadApps(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * [관리자 전용] 서비스 조회
     * @summary Read Apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsReadApps(options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsReadApps(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth2 호환 토큰 로그인, 향후 요청을 위한 액세스 토큰 받기 :param form_data: OAuth2PasswordRequestForm :return: Token
         * @summary OAuth2 호환 토큰 로그인, 향후 요청을 위한 액세스 토큰 받기
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginAccessToken: async (username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('authLoginAccessToken', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('authLoginAccessToken', 'password', password)
            const localVarPath = `/api/v1/auth/login/access-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 로그아웃
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 비밀번호 복구
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRecoverPassword: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('authRecoverPassword', 'email', email)
            const localVarPath = `/api/v1/auth/password-recovery/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 비밀번호 복구용 HTML 콘텐츠 :param email: 이메일 :return: HTMLResponse
         * @summary Recover Password Html Content
         * @param {string} email 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRecoverPasswordHtmlContent: async (email: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('authRecoverPasswordHtmlContent', 'email', email)
            const localVarPath = `/api/v1/auth/password-recovery-html-content/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh token을 사용하여 새 Access Token을 발급하는 API 엔드포인트.
         * @summary Refresh Token
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshToken: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('authRefreshToken', 'refreshToken', refreshToken)
            const localVarPath = `/api/v1/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자 신규 가입
         * @summary Register User
         * @param {UserRegister} userRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterUser: async (userRegister: UserRegister, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegister' is not null or undefined
            assertParamExists('authRegisterUser', 'userRegister', userRegister)
            const localVarPath = `/api/v1/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 비밀번호 재설정
         * @summary Reset Password
         * @param {NewPassword} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPassword: async (newPassword: NewPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newPassword' is not null or undefined
            assertParamExists('authResetPassword', 'newPassword', newPassword)
            const localVarPath = `/api/v1/auth/reset-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일 인증
         * @summary Verify Email
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmail: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authVerifyEmail', 'body', body)
            const localVarPath = `/api/v1/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * OAuth2 호환 토큰 로그인, 향후 요청을 위한 액세스 토큰 받기 :param form_data: OAuth2PasswordRequestForm :return: Token
         * @summary OAuth2 호환 토큰 로그인, 향후 요청을 위한 액세스 토큰 받기
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginAccessToken(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginAccessToken(username, password, grantType, scope, clientId, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 로그아웃
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 비밀번호 복구
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRecoverPassword(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRecoverPassword(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRecoverPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 비밀번호 복구용 HTML 콘텐츠 :param email: 이메일 :return: HTMLResponse
         * @summary Recover Password Html Content
         * @param {string} email 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRecoverPasswordHtmlContent(email: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRecoverPasswordHtmlContent(email, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRecoverPasswordHtmlContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh token을 사용하여 새 Access Token을 발급하는 API 엔드포인트.
         * @summary Refresh Token
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshToken(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshToken(refreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자 신규 가입
         * @summary Register User
         * @param {UserRegister} userRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterUser(userRegister: UserRegister, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterUser(userRegister, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRegisterUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 비밀번호 재설정
         * @summary Reset Password
         * @param {NewPassword} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetPassword(newPassword: NewPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetPassword(newPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authResetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일 인증
         * @summary Verify Email
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyEmail(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyEmail(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authVerifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * OAuth2 호환 토큰 로그인, 향후 요청을 위한 액세스 토큰 받기 :param form_data: OAuth2PasswordRequestForm :return: Token
         * @summary OAuth2 호환 토큰 로그인, 향후 요청을 위한 액세스 토큰 받기
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginAccessToken(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.authLoginAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 로그아웃
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogout(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.authLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 비밀번호 복구
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRecoverPassword(email: string, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.authRecoverPassword(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 비밀번호 복구용 HTML 콘텐츠 :param email: 이메일 :return: HTMLResponse
         * @summary Recover Password Html Content
         * @param {string} email 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRecoverPasswordHtmlContent(email: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authRecoverPasswordHtmlContent(email, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh token을 사용하여 새 Access Token을 발급하는 API 엔드포인트.
         * @summary Refresh Token
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshToken(refreshToken: string, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.authRefreshToken(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자 신규 가입
         * @summary Register User
         * @param {UserRegister} userRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterUser(userRegister: UserRegister, options?: RawAxiosRequestConfig): AxiosPromise<UserPublic> {
            return localVarFp.authRegisterUser(userRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * 비밀번호 재설정
         * @summary Reset Password
         * @param {NewPassword} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPassword(newPassword: NewPassword, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.authResetPassword(newPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일 인증
         * @summary Verify Email
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmail(body: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.authVerifyEmail(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * OAuth2 호환 토큰 로그인, 향후 요청을 위한 액세스 토큰 받기 :param form_data: OAuth2PasswordRequestForm :return: Token
     * @summary OAuth2 호환 토큰 로그인, 향후 요청을 위한 액세스 토큰 받기
     * @param {string} username 
     * @param {string} password 
     * @param {string | null} [grantType] 
     * @param {string} [scope] 
     * @param {string | null} [clientId] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginAccessToken(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 로그아웃
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 비밀번호 복구
     * @summary Recover Password
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRecoverPassword(email: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRecoverPassword(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 비밀번호 복구용 HTML 콘텐츠 :param email: 이메일 :return: HTMLResponse
     * @summary Recover Password Html Content
     * @param {string} email 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRecoverPasswordHtmlContent(email: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRecoverPasswordHtmlContent(email, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh token을 사용하여 새 Access Token을 발급하는 API 엔드포인트.
     * @summary Refresh Token
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshToken(refreshToken: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshToken(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자 신규 가입
     * @summary Register User
     * @param {UserRegister} userRegister 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterUser(userRegister: UserRegister, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterUser(userRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 비밀번호 재설정
     * @summary Reset Password
     * @param {NewPassword} newPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authResetPassword(newPassword: NewPassword, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authResetPassword(newPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일 인증
     * @summary Verify Email
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyEmail(body: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyEmail(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthCheckApi - axios parameter creator
 * @export
 */
export const HealthCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/health-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthCheckApi.healthCheckHealthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthCheckApiFp(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthCheck(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.healthCheckHealthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI {
    /**
     * 
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApi
     */
    public healthCheckHealthCheck(options?: RawAxiosRequestConfig) {
        return HealthCheckApiFp(this.configuration).healthCheckHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuth2Api - axios parameter creator
 * @export
 */
export const OAuth2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * e.g. /api/auth/google/authorize
         * @summary Oauth Authorize
         * @param {string} provider 
         * @param {string | null} [redirectUri] 
         * @param {string | null} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oAuth2OauthAuthorize: async (provider: string, redirectUri?: string | null, state?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('oAuth2OauthAuthorize', 'provider', provider)
            const localVarPath = `/api/v1/auth/{provider}/authorize`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * e.g. /api/auth/google/callback
         * @summary Oauth Callback
         * @param {string} provider 
         * @param {string} code 
         * @param {string | null} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oAuth2OauthCallback: async (provider: string, code: string, state?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('oAuth2OauthCallback', 'provider', provider)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('oAuth2OauthCallback', 'code', code)
            const localVarPath = `/api/v1/auth/{provider}/callback`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2Api - functional programming interface
 * @export
 */
export const OAuth2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuth2ApiAxiosParamCreator(configuration)
    return {
        /**
         * e.g. /api/auth/google/authorize
         * @summary Oauth Authorize
         * @param {string} provider 
         * @param {string | null} [redirectUri] 
         * @param {string | null} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oAuth2OauthAuthorize(provider: string, redirectUri?: string | null, state?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oAuth2OauthAuthorize(provider, redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2Api.oAuth2OauthAuthorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * e.g. /api/auth/google/callback
         * @summary Oauth Callback
         * @param {string} provider 
         * @param {string} code 
         * @param {string | null} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oAuth2OauthCallback(provider: string, code: string, state?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oAuth2OauthCallback(provider, code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2Api.oAuth2OauthCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OAuth2Api - factory interface
 * @export
 */
export const OAuth2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuth2ApiFp(configuration)
    return {
        /**
         * e.g. /api/auth/google/authorize
         * @summary Oauth Authorize
         * @param {string} provider 
         * @param {string | null} [redirectUri] 
         * @param {string | null} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oAuth2OauthAuthorize(provider: string, redirectUri?: string | null, state?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.oAuth2OauthAuthorize(provider, redirectUri, state, options).then((request) => request(axios, basePath));
        },
        /**
         * e.g. /api/auth/google/callback
         * @summary Oauth Callback
         * @param {string} provider 
         * @param {string} code 
         * @param {string | null} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oAuth2OauthCallback(provider: string, code: string, state?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.oAuth2OauthCallback(provider, code, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuth2Api - object-oriented interface
 * @export
 * @class OAuth2Api
 * @extends {BaseAPI}
 */
export class OAuth2Api extends BaseAPI {
    /**
     * e.g. /api/auth/google/authorize
     * @summary Oauth Authorize
     * @param {string} provider 
     * @param {string | null} [redirectUri] 
     * @param {string | null} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2Api
     */
    public oAuth2OauthAuthorize(provider: string, redirectUri?: string | null, state?: string | null, options?: RawAxiosRequestConfig) {
        return OAuth2ApiFp(this.configuration).oAuth2OauthAuthorize(provider, redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * e.g. /api/auth/google/callback
     * @summary Oauth Callback
     * @param {string} provider 
     * @param {string} code 
     * @param {string | null} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2Api
     */
    public oAuth2OauthCallback(provider: string, code: string, state?: string | null, options?: RawAxiosRequestConfig) {
        return OAuth2ApiFp(this.configuration).oAuth2OauthCallback(provider, code, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 특정 구독에 서비스 추가 API
         * @summary Add App To Subscription
         * @param {string} subscriptionId 
         * @param {string} appId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsAddAppToSubscription: async (subscriptionId: string, appId: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('subscriptionsAddAppToSubscription', 'subscriptionId', subscriptionId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('subscriptionsAddAppToSubscription', 'appId', appId)
            const localVarPath = `/api/v1/subscriptions/{subscription_id}/apps`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (appId !== undefined) {
                localVarQueryParameter['app_id'] = appId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 유저 구독 취소 API
         * @summary Cancel User Subscription
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsCancelUserSubscription: async (tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/subscriptions/cancel/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 유저 구독 정보 조회 API
         * @summary Get Subscription
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGetSubscription: async (tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/subscriptions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 구독에서 서비스 삭제 API
         * @summary Remove App From Subscription
         * @param {string} subscriptionId 
         * @param {string} appId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsRemoveAppFromSubscription: async (subscriptionId: string, appId: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('subscriptionsRemoveAppFromSubscription', 'subscriptionId', subscriptionId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('subscriptionsRemoveAppFromSubscription', 'appId', appId)
            const localVarPath = `/api/v1/subscriptions/{subscription_id}/apps/{app_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 유저 구독 생성 API
         * @summary Subscribe User
         * @param {SubscriptionCreate} subscriptionCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsSubscribeUser: async (subscriptionCreate: SubscriptionCreate, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionCreate' is not null or undefined
            assertParamExists('subscriptionsSubscribeUser', 'subscriptionCreate', subscriptionCreate)
            const localVarPath = `/api/v1/subscriptions/subscribe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 유저 구독 정보 수정 API
         * @summary Update User Subscription
         * @param {SubscriptionUpdate} subscriptionUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsUpdateUserSubscription: async (subscriptionUpdate: SubscriptionUpdate, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionUpdate' is not null or undefined
            assertParamExists('subscriptionsUpdateUserSubscription', 'subscriptionUpdate', subscriptionUpdate)
            const localVarPath = `/api/v1/subscriptions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 특정 구독에 서비스 추가 API
         * @summary Add App To Subscription
         * @param {string} subscriptionId 
         * @param {string} appId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsAddAppToSubscription(subscriptionId: string, appId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsAddAppToSubscription(subscriptionId, appId, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.subscriptionsAddAppToSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 유저 구독 취소 API
         * @summary Cancel User Subscription
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsCancelUserSubscription(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsCancelUserSubscription(tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.subscriptionsCancelUserSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 유저 구독 정보 조회 API
         * @summary Get Subscription
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsGetSubscription(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsGetSubscription(tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.subscriptionsGetSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 구독에서 서비스 삭제 API
         * @summary Remove App From Subscription
         * @param {string} subscriptionId 
         * @param {string} appId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsRemoveAppFromSubscription(subscriptionId: string, appId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsRemoveAppFromSubscription(subscriptionId, appId, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.subscriptionsRemoveAppFromSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 유저 구독 생성 API
         * @summary Subscribe User
         * @param {SubscriptionCreate} subscriptionCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsSubscribeUser(subscriptionCreate: SubscriptionCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsSubscribeUser(subscriptionCreate, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.subscriptionsSubscribeUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 유저 구독 정보 수정 API
         * @summary Update User Subscription
         * @param {SubscriptionUpdate} subscriptionUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsUpdateUserSubscription(subscriptionUpdate: SubscriptionUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsUpdateUserSubscription(subscriptionUpdate, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.subscriptionsUpdateUserSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * 특정 구독에 서비스 추가 API
         * @summary Add App To Subscription
         * @param {string} subscriptionId 
         * @param {string} appId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsAddAppToSubscription(subscriptionId: string, appId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionPublic> {
            return localVarFp.subscriptionsAddAppToSubscription(subscriptionId, appId, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 유저 구독 취소 API
         * @summary Cancel User Subscription
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsCancelUserSubscription(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.subscriptionsCancelUserSubscription(tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 유저 구독 정보 조회 API
         * @summary Get Subscription
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGetSubscription(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionPublic> {
            return localVarFp.subscriptionsGetSubscription(tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 구독에서 서비스 삭제 API
         * @summary Remove App From Subscription
         * @param {string} subscriptionId 
         * @param {string} appId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsRemoveAppFromSubscription(subscriptionId: string, appId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionPublic> {
            return localVarFp.subscriptionsRemoveAppFromSubscription(subscriptionId, appId, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 유저 구독 생성 API
         * @summary Subscribe User
         * @param {SubscriptionCreate} subscriptionCreate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsSubscribeUser(subscriptionCreate: SubscriptionCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionPublic> {
            return localVarFp.subscriptionsSubscribeUser(subscriptionCreate, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 유저 구독 정보 수정 API
         * @summary Update User Subscription
         * @param {SubscriptionUpdate} subscriptionUpdate 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsUpdateUserSubscription(subscriptionUpdate: SubscriptionUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionPublic> {
            return localVarFp.subscriptionsUpdateUserSubscription(subscriptionUpdate, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 특정 구독에 서비스 추가 API
     * @summary Add App To Subscription
     * @param {string} subscriptionId 
     * @param {string} appId 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsAddAppToSubscription(subscriptionId: string, appId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsAddAppToSubscription(subscriptionId, appId, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 유저 구독 취소 API
     * @summary Cancel User Subscription
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsCancelUserSubscription(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsCancelUserSubscription(tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 유저 구독 정보 조회 API
     * @summary Get Subscription
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsGetSubscription(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsGetSubscription(tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 구독에서 서비스 삭제 API
     * @summary Remove App From Subscription
     * @param {string} subscriptionId 
     * @param {string} appId 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsRemoveAppFromSubscription(subscriptionId: string, appId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsRemoveAppFromSubscription(subscriptionId, appId, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 유저 구독 생성 API
     * @summary Subscribe User
     * @param {SubscriptionCreate} subscriptionCreate 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsSubscribeUser(subscriptionCreate: SubscriptionCreate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsSubscribeUser(subscriptionCreate, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 유저 구독 정보 수정 API
     * @summary Update User Subscription
     * @param {SubscriptionUpdate} subscriptionUpdate 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsUpdateUserSubscription(subscriptionUpdate: SubscriptionUpdate, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsUpdateUserSubscription(subscriptionUpdate, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 내 계정 탈퇴
         * @summary Delete Me
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteMe: async (tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일로 사용자 정보 조회
         * @summary Read User By Email
         * @param {string} email 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersReadUserByEmail: async (email: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('usersReadUserByEmail', 'email', email)
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자 ID로 사용자 정보 조회
         * @summary Read User By Id
         * @param {string} userId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersReadUserById: async (userId: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersReadUserById', 'userId', userId)
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 현재 사용자 정보 조회
         * @summary Read User Me
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersReadUserMe: async (tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일의 로컬 부분 또는 이름의 일부로 사용자 검색 (도메인 제외)
         * @summary Search User
         * @param {string | null} [email] 
         * @param {string | null} [fullname] 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSearchUser: async (email?: string | null, fullname?: string | null, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (fullname !== undefined) {
                localVarQueryParameter['fullname'] = fullname;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내 정보 업데이트
         * @summary Update Me
         * @param {UserUpdateMe} userUpdateMe 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateMe: async (userUpdateMe: UserUpdateMe, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateMe' is not null or undefined
            assertParamExists('usersUpdateMe', 'userUpdateMe', userUpdateMe)
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateMe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내 비밀번호 변경
         * @summary Update Password
         * @param {UpdatePassword} updatePassword 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdatePassword: async (updatePassword: UpdatePassword, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePassword' is not null or undefined
            assertParamExists('usersUpdatePassword', 'updatePassword', updatePassword)
            const localVarPath = `/api/v1/users/me/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 내 계정 탈퇴
         * @summary Delete Me
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeleteMe(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeleteMe(tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersDeleteMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일로 사용자 정보 조회
         * @summary Read User By Email
         * @param {string} email 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersReadUserByEmail(email: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersReadUserByEmail(email, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersReadUserByEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자 ID로 사용자 정보 조회
         * @summary Read User By Id
         * @param {string} userId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersReadUserById(userId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersReadUserById(userId, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersReadUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 현재 사용자 정보 조회
         * @summary Read User Me
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersReadUserMe(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersReadUserMe(tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersReadUserMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일의 로컬 부분 또는 이름의 일부로 사용자 검색 (도메인 제외)
         * @summary Search User
         * @param {string | null} [email] 
         * @param {string | null} [fullname] 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSearchUser(email?: string | null, fullname?: string | null, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSearchPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSearchUser(email, fullname, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersSearchUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내 정보 업데이트
         * @summary Update Me
         * @param {UserUpdateMe} userUpdateMe 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdateMe(userUpdateMe: UserUpdateMe, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdateMe(userUpdateMe, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUpdateMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내 비밀번호 변경
         * @summary Update Password
         * @param {UpdatePassword} updatePassword 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdatePassword(updatePassword: UpdatePassword, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdatePassword(updatePassword, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUpdatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 내 계정 탈퇴
         * @summary Delete Me
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteMe(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.usersDeleteMe(tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일로 사용자 정보 조회
         * @summary Read User By Email
         * @param {string} email 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersReadUserByEmail(email: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserPublic> {
            return localVarFp.usersReadUserByEmail(email, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자 ID로 사용자 정보 조회
         * @summary Read User By Id
         * @param {string} userId 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersReadUserById(userId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserPublic> {
            return localVarFp.usersReadUserById(userId, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 현재 사용자 정보 조회
         * @summary Read User Me
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersReadUserMe(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserPublic> {
            return localVarFp.usersReadUserMe(tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일의 로컬 부분 또는 이름의 일부로 사용자 검색 (도메인 제외)
         * @summary Search User
         * @param {string | null} [email] 
         * @param {string | null} [fullname] 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSearchUser(email?: string | null, fullname?: string | null, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSearchPublic>> {
            return localVarFp.usersSearchUser(email, fullname, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 내 정보 업데이트
         * @summary Update Me
         * @param {UserUpdateMe} userUpdateMe 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateMe(userUpdateMe: UserUpdateMe, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserPublic> {
            return localVarFp.usersUpdateMe(userUpdateMe, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
        /**
         * 내 비밀번호 변경
         * @summary Update Password
         * @param {UpdatePassword} updatePassword 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdatePassword(updatePassword: UpdatePassword, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.usersUpdatePassword(updatePassword, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 내 계정 탈퇴
     * @summary Delete Me
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDeleteMe(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDeleteMe(tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일로 사용자 정보 조회
     * @summary Read User By Email
     * @param {string} email 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersReadUserByEmail(email: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersReadUserByEmail(email, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자 ID로 사용자 정보 조회
     * @summary Read User By Id
     * @param {string} userId 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersReadUserById(userId: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersReadUserById(userId, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 현재 사용자 정보 조회
     * @summary Read User Me
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersReadUserMe(tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersReadUserMe(tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일의 로컬 부분 또는 이름의 일부로 사용자 검색 (도메인 제외)
     * @summary Search User
     * @param {string | null} [email] 
     * @param {string | null} [fullname] 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersSearchUser(email?: string | null, fullname?: string | null, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersSearchUser(email, fullname, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내 정보 업데이트
     * @summary Update Me
     * @param {UserUpdateMe} userUpdateMe 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdateMe(userUpdateMe: UserUpdateMe, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdateMe(userUpdateMe, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내 비밀번호 변경
     * @summary Update Password
     * @param {UpdatePassword} updatePassword 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdatePassword(updatePassword: UpdatePassword, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdatePassword(updatePassword, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UtilsApi - axios parameter creator
 * @export
 */
export const UtilsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Test emails.
         * @summary Test Email
         * @param {string} emailTo 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        utilsTestEmail: async (emailTo: string, tokenFromCookie?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailTo' is not null or undefined
            assertParamExists('utilsTestEmail', 'emailTo', emailTo)
            const localVarPath = `/api/v1/utils/test-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (emailTo !== undefined) {
                localVarQueryParameter['email_to'] = emailTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilsApi - functional programming interface
 * @export
 */
export const UtilsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilsApiAxiosParamCreator(configuration)
    return {
        /**
         * Test emails.
         * @summary Test Email
         * @param {string} emailTo 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async utilsTestEmail(emailTo: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.utilsTestEmail(emailTo, tokenFromCookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilsApi.utilsTestEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UtilsApi - factory interface
 * @export
 */
export const UtilsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilsApiFp(configuration)
    return {
        /**
         * Test emails.
         * @summary Test Email
         * @param {string} emailTo 
         * @param {string | null} [tokenFromCookie] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        utilsTestEmail(emailTo: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.utilsTestEmail(emailTo, tokenFromCookie, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilsApi - object-oriented interface
 * @export
 * @class UtilsApi
 * @extends {BaseAPI}
 */
export class UtilsApi extends BaseAPI {
    /**
     * Test emails.
     * @summary Test Email
     * @param {string} emailTo 
     * @param {string | null} [tokenFromCookie] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public utilsTestEmail(emailTo: string, tokenFromCookie?: string | null, options?: RawAxiosRequestConfig) {
        return UtilsApiFp(this.configuration).utilsTestEmail(emailTo, tokenFromCookie, options).then((request) => request(this.axios, this.basePath));
    }
}



